




<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="Reactive Programming is revolutionary but it's not always straightforward and requires a fundamental shift in mindset. In this post, we'll re-implement a classic video game and transform a programmatic-event-loop into a reactive-event-driven app using RxJS. The goal is to completely avoid external state and embrace a functional reactive style.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="thoughtram">
    <title>Taming snakes with reactive streams by thoughtram</title>
    <meta name="google-site-verification" content="o9eGPEgIETEqYGombq7NiQuBIB_qa6gz1yAL7PxKyK0">

    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#4D8799">
    <link rel="icon" sizes="192x192" href="/images/touch/chrome-touch-icon-192x192.png">

    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="thoughtram">
    <link rel="apple-touch-icon" href="/images/touch/apple-touch-icon.png">

    <!-- Tile icon for Win8 (144x144 + tile color) -->
    <meta name="msapplication-TileImage" content="/images/touch/ms-touch-icon-144x144-precomposed.png">
    <meta name="msapplication-TileColor" content="#4D8799">

    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Taming snakes with reactive streams">
    <meta property="og:description" content="Reactive Programming is revolutionary but it's not always straightforward and requires a fundamental shift in mindset. In this post, we'll re-implement a classic video game and transform a programmatic-event-loop into a reactive-event-driven app using RxJS. The goal is to completely avoid external state and embrace a functional reactive style.">
    <meta property="og:url" content="http://blog.thoughtram.io/rxjs/2017/08/24/taming-snakes-with-reactive-streams.html">
    <meta property="og:site_name" content="Articles by thoughtram">
    <meta property="og:image" content="http://blog.thoughtram.io/images/banner/reactive_snake.jpg">
    <meta property="og:publisher" content="http://www.facebook.com/thoughtram">

    <meta property="twitter:card" content="summary">
    <meta property="twitter:title" content="Taming snakes with reactive streams">
    <meta property="twitter:site" content="thoughtram Blog">

    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="/css/main.css" type="text/css">
  </head>
  <body class="sub-site">
    <!-- Add your site or app content here -->

    <!--[if lt IE 10]>
        <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
    <![endif]-->

    <header class="thtrm-header" role="banner">
      <div class="thtrm-header-bar">
        <div class="thtrm-constraint">
          <a href="http://thoughtram.io" class="thtrm-header-logo-link" title="thoughtram.io Start Page"><h1 class="thtrm-header-logo">thoughtram</h1></a>
          <div class="thtrm-header-menu-wrapper">
            <span role="button" tabindex="0" class="thtrm-header-menu-label">Menu</span>
            <ul class="thtrm-header-menu">
              <li><a title="Training" class="thtrm-header-menu-item" href="http://thoughtram.io/training.html">Training</a></li>
              <li><a title="Code Review" class="thtrm-header-menu-item" href="http://thoughtram.io/code-review.html">Code Review</a></li>
              <li><a title="Casts" class="thtrm-header-menu-item " href="http://casts.thoughtram.io">Casts</a></li>
              <li><a title="Blog" class="thtrm-header-menu-item" href="/">Blog</a></li>
            </ul>
          </div>
        </div>
      </div>
    </header>

    <main role="main" class="thtrm-main">
    <div class="thtrm-banner" style="background-image: linear-gradient(to bottom, rgba(0,0,0,0) 0%,rgba(0,0,0,0.01) 2%,#29383E 100%), url('/images/banner/reactive_snake.jpg');">
        <hgroup class="thtrm-banner-container">
          <div class="thtrm-constraint thtrm-constraint--slim">
            <h2 class="thtrm-banner-text">Taming snakes with reactive streams</h2>
            <span>by <a href="http://twitter.com/" title="Dominic Elm on Twitter">Dominic Elm</a> on Aug 24, 2017<br>32 minute read</span>

          </div>
        </hgroup>
      </div>
      <div class="thtrm-constraint thtrm-constraint--slim">

        <section class="thtrm-ad thtrm-section thtrm-section--is-promo is-sticky">
  <img width="100" src="/images/angular2-shield-inverse.svg">
  <h3 class="thtrm-section-headline">Angular Master Class in Las Palmas</h3>
  <p class="thtrm-section-text">Join our upcoming public training!</p>
  <a href="https://www.codecamps.com/aiff4/" title="Angular Master Class in Las Palmas" id="event-cta" class="thtrm-layout-divider-cta">Get a ticket <strong>&rarr;</strong></a>
</section>

        <div class="thtrm-article">

          <p>The web moves quickly and we all know it. Today, Reactive Programming is one of the hottest topics in web development and with frameworks like Angular or React, it has become much more popular especially in the modern JavaScript world. There’s been a massive move in the community from imperative programming paradigms to functional reactive paradigms. Yet, many developers struggle with it and are often overwhelmed by its complexity (large API), fundamental shift in mindset (from imperative to declarative) and the multitude of concepts.</p>

<p>While this is not always the easiest thing to do, once we get the hang of it we’ll ask ourselves <strong>how did we live without it?</strong></p>

<p>This article is not meant to be an introduction to reactive programming and if you are completely new to it, we recommend the following resources:</p>

<ul>
  <li><a href="https://egghead.io/courses/introduction-to-reactive-programming">Introduction to Reactive Programming</a> by <a href="https://twitter.com/andrestaltz">André Staltz</a></li>
  <li><a href="https://www.youtube.com/watch?v=3LKMwkuK0ZE">RxJS 5 Thinking Reactively</a> by <a href="https://twitter.com/BenLesh">Ben Lesh</a></li>
  <li><a href="https://chrisnoring.gitbooks.io/rxjs-5-ultimate/content/">RxJS 5 Ultimate</a> by <a href="https://twitter.com/chris_noring">Chris Noring</a></li>
  <li><a href="https://www.learnrxjs.io/">Learn RxJS</a> by <a href="https://twitter.com/btroncone">Brian Troncone</a></li>
  <li><a href="https://gist.github.com/btroncone/d6cf141d6f2c00dc6b35">RxJS 5 Operators By Example</a> by <a href="https://twitter.com/btroncone">Brian Troncone</a></li>
</ul>

<p>The goal of this post is to learn how to think reactively by building a classic video game that we all know and love - Snake. That’s right, a video game! They are fun but complex systems that keep a lot of external state, e.g. scores, timers, or player coordinates. For our version, we’ll make heavy use of Observables and use several different operators to completely avoid external state. At some point it might be tempting to store state outside of the Observable pipeline but remember, we want to embrace reactive programming and don’t rely on a single external variable that keeps state.</p>

<p><strong>Note</strong>: We’ll solely use <strong>HTML5</strong> and <strong>JavaScript</strong> together with <a href="http://reactivex.io/rxjs/">RxJS</a> to transform a programmatic-event-loop into a reactive-event-driven app.</p>

<p>The code is available on <a href="https://github.com/thoughtram/reactive-snake">Github</a> and a live demo can be found <a href="https://stackblitz.com/edit/reactive-snake?file=main.ts">here</a>. I encourage you to clone the project, fiddle with it and implement cool new game features. If you do, ping me on <a href="https://twitter.com/elmd_">Twitter</a>.</p>

<div class="thtrm-toc is-sticky">
  <h3 class="no_toc" id="table-of-contents">TABLE OF CONTENTS</h3>
<ul id="markdown-toc">
  <li><a href="#the-game" id="markdown-toc-the-game">The game</a></li>
  <li><a href="#setting-up-the-stage" id="markdown-toc-setting-up-the-stage">Setting up the stage</a></li>
  <li><a href="#identifying-the-source-streams" id="markdown-toc-identifying-the-source-streams">Identifying the source streams</a></li>
  <li><a href="#steering-the-snake" id="markdown-toc-steering-the-snake">Steering the snake</a>    <ul>
      <li><a href="#the-direction-stream" id="markdown-toc-the-direction-stream">The direction$ stream</a></li>
    </ul>
  </li>
  <li><a href="#keeping-track-of-the-length" id="markdown-toc-keeping-track-of-the-length">Keeping track of the length</a>    <ul>
      <li><a href="#behaviorsubject-to-the-rescue" id="markdown-toc-behaviorsubject-to-the-rescue">BehaviorSubject to the rescue</a></li>
      <li><a href="#implementing-score" id="markdown-toc-implementing-score">Implementing score$</a></li>
    </ul>
  </li>
  <li><a href="#taming-the-snake" id="markdown-toc-taming-the-snake">Taming the snake$</a></li>
  <li><a href="#generating-apples" id="markdown-toc-generating-apples">Generating apples</a>    <ul>
      <li><a href="#broadcasting-events" id="markdown-toc-broadcasting-events">Broadcasting events</a></li>
    </ul>
  </li>
  <li><a href="#putting-everything-together" id="markdown-toc-putting-everything-together">Putting everything together</a>    <ul>
      <li><a href="#maintaining-performance" id="markdown-toc-maintaining-performance">Maintaining performance</a></li>
      <li><a href="#rendering-the-scene" id="markdown-toc-rendering-the-scene">Rendering the scene</a></li>
    </ul>
  </li>
  <li><a href="#future-work" id="markdown-toc-future-work">Future work</a></li>
  <li><a href="#special-thanks" id="markdown-toc-special-thanks">Special Thanks</a></li>
</ul>

</div>

<h2 id="the-game">The game</h2>

<p>As mentioned earlier, we are going to re-create Snake, a classic video game from the late 1970s. But instead of simply copying the game, we add a little bit of variation to it. Here’s how the game works.</p>

<p>As a player you control a line that resembles a hungry snake. The goal is to eat as many apples as you can to grow as long as possible. The apples can be found at random positions on the screen. Each time the snake eats an apple, its tail grows longer. Walls will not stop you! But listen up, you must try to avoid hitting your own trail at all costs. If you don’t, the game is over. How long can you survive?</p>

<p>Here’s a preview of what we are going to build:</p>

<p><img src="/images/snake_preview.gif" alt="button state machine" /></p>

<p>For this specific implementation the snake is represented as a line of blue squares where its head is painted in black. Can you tell how the fruits look? Exactly, red squares. Everything is a square and that’s not because they look so beautiful but they are very simple geometric shapes and easy to draw. The graphics are not very shiny but hey, it’s about making the shift from imperative programming to reactive programming and not about game art.</p>

<h2 id="setting-up-the-stage">Setting up the stage</h2>

<p>Before we can start with the game’s functionality, we need set up a <code>&lt;canvas&gt;</code> element that gives us powerful drawing APIs from within JavaScript. We’ll use the canvas to draw our graphics including the playing area, the snake, the apples and basically everything we need for our game. In other words, the game will be rendered entirely on the <code>&lt;canvas&gt;</code> element.</p>

<p>If this is completely new to you, check out <a href="https://egghead.io/courses/learn-html5-graphics-and-animation">this</a> course on egghead by Keith Peters.</p>

<p>The <code>index.html</code> is quite simple because most of the <em>magic</em> happens with JavaScript.</p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;head&gt;</span>
  <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"utf-8"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;title&gt;</span>Reactive Snake<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
  <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"/main.bundle.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span></code></pre></div>

<p>The script that we add to the body is essentially the output of the build process and contains all of our code. However, you may be wondering why there is no such <code>&lt;canvas&gt;</code> element inside the <code>&lt;body&gt;</code>. It’s because we’ll create that element using JavaScript. In addition, we add a few constants that define how many <code>rows</code> and <code>columns</code> we have as well as the <code>width</code> and <code>height</code> of the canvas.</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">COLS</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">ROWS</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">GAP_SIZE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">CELL_SIZE</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">CANVAS_WIDTH</span> <span class="o">=</span> <span class="nx">COLS</span> <span class="o">*</span> <span class="p">(</span><span class="nx">CELL_SIZE</span> <span class="o">+</span> <span class="nx">GAP_SIZE</span><span class="p">);</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">CANVAS_HEIGHT</span> <span class="o">=</span> <span class="nx">ROWS</span> <span class="o">*</span> <span class="p">(</span><span class="nx">CELL_SIZE</span> <span class="o">+</span> <span class="nx">GAP_SIZE</span><span class="p">);</span>

<span class="kr">export</span> <span class="kd">function</span> <span class="nx">createCanvasElement</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'canvas'</span><span class="p">);</span>
  <span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">CANVAS_WIDTH</span><span class="p">;</span>
  <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span> <span class="nx">CANVAS_HEIGHT</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">canvas</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>With that in place we can call this function, create a <code>&lt;canvas&gt;</code> element on the fly and append it to the <code>&lt;body&gt;</code> of our page:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nx">createCanvasElement</span><span class="p">();</span>
<span class="kd">let</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="s1">'2d'</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">canvas</span><span class="p">);</span></code></pre></div>

<p>Note that we are also getting a reference to the <code>CanvasRenderingContext2D</code> by calling <code>getContext('2d')</code> on the <code>&lt;canvas&gt;</code> element. This 2D rendering context for the canvas allows us to draw for example rectangles, text, lines, paths and much more.</p>

<p>We’re good to go! Let’s start working on the core mechanics of the game.</p>

<h2 id="identifying-the-source-streams">Identifying the source streams</h2>

<p>From the preview and the game description we know that we need the following features:</p>

<ul>
  <li>Navigate the snake using the arrow keys</li>
  <li>Keep track of the player’s score</li>
  <li>Keep track of the snake (includes eating and moving)</li>
  <li>Keep track of the apples on the field (includes generating new apples)</li>
</ul>

<p>In reactive programming it’s all about programming with data streams, streams of input data. Conceptually, when a reactive program is executed, it sets up an observable pipeline that acts upon changes, e.g. a user has interacted with the application by pressing a key on the keyboard or simply a tick of an interval. So it’s all about figuring out <strong>what can change</strong>. Those <em>changes</em> often define the <strong>source streams</strong>. The key is to come up with the streams that represent the <strong>primary source of change</strong> and then compose them together to calculate whatever you need, e.g. the game state.</p>

<p>Let’s try to find our source streams by looking at the featurs above.</p>

<p>First of all, user input is definitely something that will change over time. The player navigates the hungry snake using the arrow keys. That means our first source stream is <code>keydown$</code> which will emit values whenever a key is pressed down.</p>

<p>Next we need to keep track of the player’s score. The score basically depends on how many apples the snake has eaten. We could say that the score depends on the length of the snake because whenever the snake grows we want to increase the score by <code>1</code>. Therefore, our next source stream is <code>snakeLength$</code>.</p>

<p>Again, it is important to figure out the <strong>main</strong> sources from which we can compute whatever you need, e.g. the score. In most cases, the source streams are combined and refined into more concrete streams of data. We’ll see this in action in a minute. For now, let’s continue with identifying our main source streams.</p>

<p>So far, we got the user input and the score in place. What’s left are the more <strong>game-facing</strong> or <strong>interactive</strong> streams, such as the snake or the apples.</p>

<p>Let’s start with the snake. The core mechanic of the snake is simple; it moves over time and the more apples it eats the bigger it grows. But what exactly is the <strong>source</strong> of the snake? For now, we can forget about the fact that it eats and grows because what matters is that it primarily depends on a <strong>time factor</strong> as it moves <strong>over time</strong>, e.g. <code>5</code> pixels every <code>200ms</code>. So our source stream is an interval that produces a value after each period and we call this <code>ticks$</code>. This stream also determines the speed of our snake.</p>

<p>Last but not least the apples. With everyting else in place, the apples are farily easy. This stream basically depends on the snake. Everytime the snake moves we check whether the head collides with an apple or not. If it does, we remove that apple and generate a new one at a random position on the field. That said, we don’t need to introduce a new source stream for the apples.</p>

<p>Great, that’s it for the source streams. Here’s a brief overview of the all source streams we need for our game:</p>

<ul>
  <li><code>keydown$</code>: keydown events (KeyboardEvent)</li>
  <li><code>snakeLength$</code>: represents the length of the snake (Number)</li>
  <li><code>ticks$</code>: interval that represents the pace of the snake (Number)</li>
</ul>

<p>These source streams build the basis for our game from which we can calculate all other values we need including the score, snake and apples.</p>

<p>In the next sections we’ll look closely at how to implement each of these source streams and compose them to generate the data we need.</p>

<h2 id="steering-the-snake">Steering the snake</h2>

<p>Let’s dive right into code and implement the steering mechanism for our snake. As mentioned in the previous section the steering depends on keyboard inputs. Turns out it’s deceptively simple and the first step is to create an observable sequence from keyboard events. For this we can leverage the <code>fromEvent()</code> operator:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">keydown$</span> <span class="o">=</span> <span class="nx">Observable</span><span class="p">.</span><span class="nx">fromEvent</span><span class="p">(</span><span class="nb">document</span><span class="p">,</span> <span class="s1">'keydown'</span><span class="p">);</span></code></pre></div>

<p>This is our very first source stream and it will emit a <code>KeyboardEvent</code> everytime the user presses down a key. Note that literally every <code>keydown</code> event is emitted. Therefore, we also get events for keys that we are not really interested in and that’s basically everything else but the arrow keys. But before we tackle this specific issue, we define a constant map of directions:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">export</span> <span class="kr">interface</span> <span class="nx">Point2D</span> <span class="p">{</span>
  <span class="nl">x</span><span class="p">:</span> <span class="nx">number</span><span class="p">;</span>
  <span class="nl">y</span><span class="p">:</span> <span class="nx">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="kr">interface</span> <span class="nx">Directions</span> <span class="p">{</span>
  <span class="p">[</span><span class="nx">key</span><span class="err">:</span> <span class="nx">number</span><span class="p">]</span><span class="err">:</span> <span class="nx">Point2D</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="kr">const</span> <span class="nx">DIRECTIONS</span><span class="err">:</span> <span class="nx">Directions</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">37</span><span class="p">:</span> <span class="p">{</span> <span class="nl">x</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">0</span> <span class="p">},</span> <span class="c1">// Left Arrow</span>
  <span class="mi">39</span><span class="err">:</span> <span class="p">{</span> <span class="nl">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="err">:</span> <span class="mi">0</span> <span class="p">},</span>  <span class="c1">// Right Arrow</span>
  <span class="mi">38</span><span class="err">:</span> <span class="p">{</span> <span class="nl">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">y</span><span class="err">:</span> <span class="o">-</span><span class="mi">1</span> <span class="p">},</span> <span class="c1">// Up Arrow</span>
  <span class="mi">40</span><span class="err">:</span> <span class="p">{</span> <span class="nl">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">y</span><span class="err">:</span> <span class="mi">1</span> <span class="p">}</span>   <span class="c1">// Down Arrow</span>
<span class="p">};</span></code></pre></div>

<p>By looking at the <code>KeyboardEvent</code> object it appears that every key has a unique <code>keyCode</code>. In order to get the codes for the arrow keys we can use <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode">this</a> table.</p>

<p>Each direction is of type <code>Point2D</code> which is simply an object with an <code>x</code> and <code>y</code> property. The value for for each property can either be <code>1</code>, <code>-1</code> or <code>0</code>, indicating where the snake should be heading. Later, we’ll use the direction to derive the new grid position for the snake’s head and tail.</p>

<h3 id="the-direction-stream">The direction$ stream</h3>

<p>So, we already have a stream for <code>keydown</code> events and everytime the player presses down a key we need to <strong>map</strong> the value, which will be a <code>KeyboardEvent</code>, to one of the direction vectors above. For that we can use the <code>map()</code> operator to project each keyboard event to a direction vector.</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">direction$</span> <span class="o">=</span> <span class="nx">keydown$</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">event</span><span class="err">:</span> <span class="nx">KeyboardEvent</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">DIRECTIONS</span><span class="p">[</span><span class="nx">event</span><span class="p">.</span><span class="nx">keyCode</span><span class="p">])</span></code></pre></div>

<p>As mentioned earlier, we’ll receive <strong>every</strong> keydown event because we are not filtering out the ones that we are not interested in, such as the character keys. However, one could argue that we are already filtering out events by looking them up in the directions map. For every <code>keyCode</code> that is not defined in that map it will return <code>undefined</code>. Nevertheless, that’s not really filtering out values on the stream which is why we can use the <code>filter()</code> operator to only pipe through desired values.</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">direction$</span> <span class="o">=</span> <span class="nx">keydown$</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">event</span><span class="err">:</span> <span class="nx">KeyboardEvent</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">DIRECTIONS</span><span class="p">[</span><span class="nx">event</span><span class="p">.</span><span class="nx">keyCode</span><span class="p">])</span>
  <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">direction</span> <span class="o">=&gt;</span> <span class="o">!!</span><span class="nx">direction</span><span class="p">)</span></code></pre></div>

<p>Ok, that was easy. The code above is perfectly fine and works as expected. However, there’s still some room for improvement. Can you think of something?</p>

<p>Well, one thing is that we want to prevent the snake from going into the opposite direction, e.g. from right to left or up and down. It doesn’t really make sense to allow such behavior because the number one rule is to avoid hitting your own trail, remember?</p>

<p>The solution is fairly easy. We cache the previous direction and when a new event is emitted we check if the new direction is not equal to the opposite of the last one. Here’s a function that calculates the <code>next</code> direction:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">nextDirection</span><span class="p">(</span><span class="nx">previous</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">isOpposite</span> <span class="o">=</span> <span class="p">(</span><span class="nx">previous</span><span class="err">:</span> <span class="nx">Point2D</span><span class="p">,</span> <span class="nx">next</span><span class="err">:</span> <span class="nx">Point2D</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">next</span><span class="p">.</span><span class="nx">x</span> <span class="o">===</span> <span class="nx">previous</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="nx">next</span><span class="p">.</span><span class="nx">y</span> <span class="o">===</span> <span class="nx">previous</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">isOpposite</span><span class="p">(</span><span class="nx">previous</span><span class="p">,</span> <span class="nx">next</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">previous</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">next</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>This is the first time we are tempted to store state outside of the Observable pipeline because we somehow need to keep track of the previous direction right? An easy solution is to simply keep the previous direction in an external state variable. But wait! We wanted to avoid this, right?</p>

<p>To avoid external state, we need a way to sort of aggregate infinite Observables. RxJS has a very convenient operator we can use to solve our problem - <code>scan()</code>.</p>

<p>The <code>scan()</code> operator is very similar to <code>Array.reduce()</code> but instead of only returning the last value, it emits each intermediate result. With <code>scan()</code> we can basically accumulate values and reduce a stream of incoming events to a single value infinitely. This way we can keep track of the previous direction without relying on external state.</p>

<p>Let’s apply this and take a look at our final <code>direction$</code> stream:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">direction$</span> <span class="o">=</span> <span class="nx">keydown$</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">event</span><span class="err">:</span> <span class="nx">KeyboardEvent</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">DIRECTIONS</span><span class="p">[</span><span class="nx">event</span><span class="p">.</span><span class="nx">keyCode</span><span class="p">])</span>
  <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">direction</span> <span class="o">=&gt;</span> <span class="o">!!</span><span class="nx">direction</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">scan</span><span class="p">(</span><span class="nx">nextDirection</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">startWith</span><span class="p">(</span><span class="nx">INITIAL_DIRECTION</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">distinctUntilChanged</span><span class="p">();</span></code></pre></div>

<p>Notice that we are using <code>startWith()</code> to emit an inital value before beginning to emit values from the source Observable (<code>keydown$</code>). Without this operator our Observable would start emitting only when the player presses a key.</p>

<p>The second improvement is to <em>only</em> emit values when the emitted direction is different from the previous one. In other words, we only want <strong>distinct</strong> values. You might have noticed <code>distinctUntilChanged()</code> in the snippet above. This operator does the dirty work for us and suppresses duplicate items. Note that <code>distinctUntilChanged()</code> only filters out identical values unless a different one is emitted in between.</p>

<p>The following figure visualizes our <code>direction$</code> stream and how it works. Values painted in blue represent initial values, yellow means the value was changed on the Observable pipeline and values emitted on the <strong>result</strong> stream are colored orange.</p>

<p><img src="/images/snake_direction.png" width="70%" alt="direction stream" /></p>

<h2 id="keeping-track-of-the-length">Keeping track of the length</h2>

<p>Before we implement the snake itself, let’s come up with an idea to keep track of its length. Why do we need the length in the first place? Well, we use that information to model the score. It’s right that in an imperative world we’d simply check if there was a collision whenever the snake moves and if that’s the case we increase the score. So there is actually no need to keep track of the length. However, it would introduce yet another external state variable which we want to avoid at all costs.</p>

<p>In a reactive world it’s a bit different. One naive approach could be to use the <code>snake$</code> stream and every time it emits a value we know that the snake has grown in length. While it really depends on the implementation of <code>snake$</code>, this is not how we’ll implement it. From the beginning we know that it depends on <code>ticks$</code> as it moves a certain distance over time. As such, <code>snake$</code> will accumulate an array of body segments and because it’s based on <code>ticks$</code> it will generate a value every <code>x</code> milliseconds. That said, even if the snake does not collide with anything, <code>snake$</code> will still produce distinct values. That’s because the snake is constantly moving on the field and therefore the array will always be different.</p>

<p>This can be a bit tricky to grasp because there are some peer dependencies between the different streams. For example <code>apples$</code> will depend on <code>snake$</code>. The reason for this is that, everytime the snake moves we need the array of body segments to check if any of these pieces collides with an apple. While the <code>apples$</code> stream itself will accumulate an array of apples, we need a mechanism to model collisions that, at the same time, avoids a circular dependency.</p>

<h3 id="behaviorsubject-to-the-rescue">BehaviorSubject to the rescue</h3>

<p>The solution to this is that we’ll implement a <em>broadcasting</em> mechanism using a <code>BehaviorSubject</code>. RxJS offers different types of Subjects with different functionalities. As such, the <code>Subject</code> class provides the base for creating more specialized Subjects. In a nutshell, a Subject is a type that implements both <code>Observer</code> and <code>Observable</code> types. Observables define the data flow and produce the data while Observers can subscribe to Observables and receive the data.</p>

<p>A <code>BehaviorSubject</code> is a more specialized Subject that represents a value that changes over time. Now, when an Observer subscribes to a <code>BehaviorSubject</code>, it will receive the last emitted value and then all subsequent values. Its uniqueness lies in the fact that it requires a <strong>starting value</strong>, so that all Observers will at least receive one value on subscription.</p>

<p>Let’s go ahead and create a new <code>BehaviorSubject</code> with an initial value of <code>SNAKE_LENGTH</code>:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// SNAKE_LENGTH specifies the inital length of our snake</span>
<span class="kd">let</span> <span class="nx">length$</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BehaviorSubject</span><span class="o">&lt;</span><span class="nx">number</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">SNAKE_LENGTH</span><span class="p">);</span></code></pre></div>

<p>From here it’s only a small step to implement <code>snakeLength$</code>:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">snakeLength$</span> <span class="o">=</span> <span class="nx">length$</span>
  <span class="p">.</span><span class="nx">scan</span><span class="p">((</span><span class="nx">step</span><span class="p">,</span> <span class="nx">snakeLength</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">snakeLength</span> <span class="o">+</span> <span class="nx">step</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">share</span><span class="p">();</span></code></pre></div>

<p>In the code above we can see that <code>snakeLength$</code> is based on <code>length$</code> which is our <code>BehaviorSubject</code>. This means that whenever we feed a new value to the Subject using <code>next()</code>, it will be emitted on <code>snakeLength$</code>. In addition, we use <code>scan()</code> to accumulate the length over time. Cool, but you may be wondering what that <code>share()</code> is all about, right?</p>

<p>As already mentioned, <code>snakeLength$</code> will later be used as an input for <code>snake$</code> but at the same time acts as a source stream for the player’s score. As a result, we would end up <strong>recreating</strong> that source stream with the second subscriptions to the same Observable. This happens because <code>length$</code> is a <strong>cold</strong> Observable.</p>

<p>If you are completely new to hot and cold Observables, we have written an article on <a href="/angular/2016/06/16/cold-vs-hot-observables.html">Cold vs Hot Observables</a>.</p>

<p>The point is that, we use <code>share()</code> to allow multiple subscriptions to an Observable that would otherwise recreate its source with every subscription. This operator automatically creates a Subject between the original source and all future subscribers. As soon as the number of subscribers goes from zero to one it will connect the Subject to the underlying source Observable and broadcast all its notifications. All future subscribers will be connected to that in-between Subject, so that effectively there’s just one subscription to the underlying cold Observable. This is called <strong>multicasting</strong> and will make you stand out on dinner parties.</p>

<p>Awesome! Now that we have a mechanism that we can use to broadcast values to multiple subscribers, we can go ahead and implement <code>score$</code>.</p>

<h3 id="implementing-score">Implementing score$</h3>

<p>The player’s score is as simple as it can get. Equipped with <code>snakeLength$</code> we can now create the <code>score$</code> stream that simply accumulates the player’s score using <code>scan()</code>:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">score$</span> <span class="o">=</span> <span class="nx">snakeLength$</span>
  <span class="p">.</span><span class="nx">startWith</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">scan</span><span class="p">((</span><span class="nx">score</span><span class="p">,</span> <span class="nx">_</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">score</span> <span class="o">+</span> <span class="nx">POINTS_PER_APPLE</span><span class="p">);</span></code></pre></div>

<p>We basically use <code>snakeLength$</code> or rather <code>length$</code> to notify subscribers that there’s been a collision and if there was, we just increase the score by <code>POINTS_PER_APPLE</code>, a constant amount of points per apple. Note that <code>startWith(0)</code> must be added before <code>scan()</code> to avoid specifying a <em>seed</em> (initial accumulator value).</p>

<p>Let’s look at a more visual representation of what we just implemented:</p>

<p><img src="/images/snake_length_and_score.png" width="70%" alt="snake length and score" /></p>

<p>By looking at the figure above you may be wondering why the initial value of the <code>BehaviorSubject</code> only shows up on <code>snakeLength$</code> and is missing on <code>score$</code>. That’s because the first subscriber will cause <code>share()</code> to subscribe to the underlying data source and because the underlying data source immediately emits a value, the value has already passed by the time that the subsequent subscriptions has happened.</p>

<p>Sweet. With that in place, let’s implement the stream for our snake. Isn’t this exciting?</p>

<h2 id="taming-the-snake">Taming the snake$</h2>

<p>So far, we have learned a bunch of operators and we can use them to implement our <code>snake$</code> stream. As discussed in the beginning of this post, we need some sort of <em>ticker</em> that keeps our hungry snake moving. Turns out there’s a handy operator for that called <code>interval(x)</code> which emits a value every <code>x</code> milliseconds. We’ll call each value <em>tick</em>.</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">ticks$</span> <span class="o">=</span> <span class="nx">Observable</span><span class="p">.</span><span class="nx">interval</span><span class="p">(</span><span class="nx">SPEED</span><span class="p">);</span></code></pre></div>

<p>From here it’s only a small stretch to the final <code>snake$</code> stream. For every <em>tick</em>, depending on whether the snake has eaten an apple, we want to either move it foward or add new segment. Therefore, we can use the all so familiar <code>scan()</code> operator to accumulate an array of body segments. But, as you may have guessed, we’re facing a problem. Where’s the <code>direction$</code> or <code>snakeLength$</code> stream coming into play?</p>

<p>Absolutely legitimate question to ask. The direction nor the snake’s length is easily accessible from within our <code>snake$</code> stream unless we kept those information in a variable outside of the Observable pipeline. But again, we would be breaking our rule of not modifying external state.</p>

<p>Luckily, RxJS offers yet another very convenient operator called <code>withLatestFrom()</code>. It’s an operator used to combine streams and that’s exactly what we’re looking for. This operator is applied to a <em>primary</em> source that controls when data is emitted on the result stream. In other words, you can think of <code>withLatestFrom()</code> as a way to <strong>throttle</strong> the output of a secondary stream.</p>

<p>With the above, we have the tools we need to finally implement the hungry <code>snake$</code>:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">snake$</span> <span class="o">=</span> <span class="nx">ticks$</span>
  <span class="p">.</span><span class="nx">withLatestFrom</span><span class="p">(</span><span class="nx">direction$</span><span class="p">,</span> <span class="nx">snakeLength$</span><span class="p">,</span> <span class="p">(</span><span class="nx">_</span><span class="p">,</span> <span class="nx">direction</span><span class="p">,</span> <span class="nx">snakeLength</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">direction</span><span class="p">,</span> <span class="nx">snakeLength</span><span class="p">])</span>
  <span class="p">.</span><span class="nx">scan</span><span class="p">(</span><span class="nx">move</span><span class="p">,</span> <span class="nx">generateSnake</span><span class="p">())</span>
  <span class="p">.</span><span class="nx">share</span><span class="p">();</span></code></pre></div>

<p>Our <em>primary</em> source is <code>ticks$</code> and whenever a new value comes down the pipe, we take the latest
values from both <code>direction$</code> and <code>snakeLength$</code>. Note that even if the <em>secondary</em> streams frequently emit values, for example if the player is smashing his head on the keyboard, we’d only be proccessing the data for each <em>tick</em>.</p>

<p>In addition, we are passing a <strong>selector</strong> function to <code>withLatestFrom</code> which is invoked when the <em>primary</em> stream produces a value. This function is optional and if omitted, a list with all elements is yielded.</p>

<p>We’ll leave out the explanation for the <code>move()</code> function as the primary goal of this post is to facilitate the fundamental shift in mindset. Nonetheless, you can find the source code for this on <a href="https://github.com/d3lm/reactive-snake/blob/master/src/utils.ts#L25-L45">GitHub</a>.</p>

<p>Here’s a figure that visually demonstrates the code above:</p>

<p><img src="/images/snake_stream.png" width="110%" alt="snake stream" /></p>

<p>See how we <em>throttle</em> <code>direction$</code>? The point is that <code>withLatestFrom()</code> is very practical when you want to <strong>combine</strong> multiple streams and you are not interested in producing values on the Observable pipeline when <strong>either</strong> of the streams emit data.</p>

<h2 id="generating-apples">Generating apples</h2>

<p>You may notice that implementing our core building blocks for the game becomes easier as we learn more and more operators. If you made it so far then the rest is going to be easy peasy.</p>

<p>So far we have implemented a couple of streams such as <code>direction$</code>, <code>snakeLength$</code>, <code>score$</code> and <code>snake$</code>. If we combine them together we could already navigate that beast of snake around. But what is this game if there’s nothing to devour. Quite boring.</p>

<p>Let’s generate some apples to satisfy our snake’s appetite. First, let’s clarify what the state we need to preserve. Well, it could either be a single object or an array of objects. For our implementation we go with an array of apples. You hear the bells ringing?</p>

<p>Right, we can use <code>scan()</code> again to accumulate an array of apples. We start with an initial value and every time the snake moves, we check if there was a collision. If that’s the case, we generate a new apple and return a <strong>new</strong> array. This way we can leverage <code>distinctUntilChanged()</code> to filter out identical values.</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">apples$</span> <span class="o">=</span> <span class="nx">snake$</span>
  <span class="p">.</span><span class="nx">scan</span><span class="p">(</span><span class="nx">eat</span><span class="p">,</span> <span class="nx">generateApples</span><span class="p">())</span>
  <span class="p">.</span><span class="nx">distinctUntilChanged</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">share</span><span class="p">();</span></code></pre></div>

<p>Cool! This means that whenever <code>apples$</code> produces a new value we can assume that our snake has devoured one of those tasty fruits. What’s left is to increase to score and also notify other streams about this event, such as <code>snake$</code> that takes the latest value from <code>snakeLength$</code> to figure out whether to add a new body segment.</p>

<h3 id="broadcasting-events">Broadcasting events</h3>

<p>Earlier we have implemented this <strong>broadcasting</strong> mechanism, remember? Let’s use that to trigger the desired actions. Here’s our code for <code>eat()</code>:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">eat</span><span class="p">(</span><span class="nx">apples</span><span class="err">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">Point2D</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">snake</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">head</span> <span class="o">=</span> <span class="nx">snake</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">apples</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">checkCollision</span><span class="p">(</span><span class="nx">apples</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">head</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">apples</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
      <span class="c1">// length$.next(POINTS_PER_APPLE);</span>
      <span class="k">return</span> <span class="p">[...</span><span class="nx">apples</span><span class="p">,</span> <span class="nx">getRandomPosition</span><span class="p">(</span><span class="nx">snake</span><span class="p">)];</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">apples</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>A simple solution is to call <code>length$.next(POINTS_PER_APPLE)</code> right inside that <code>if</code> block. But then we’re facing a problem because we couldn’t extract this <em>utility</em> method into its own module (ES2015 module). In ES2015 modules are stored in files and there’s exactly one module per file. The goal is to organize our code in a way that is easy to maintain and to reason about.</p>

<p>A more <em>sophisticated</em> solution is to introduce yet another stream called <code>applesEaten$</code>. This stream is based on <code>apples$</code> and every time a new value is emitted on the stream, we’d like to perform some kind of <strong>action</strong>, calling <code>length$.next()</code>. To do so we can use the <code>do()</code> operator which will execute some piece of code for each <em>event</em>.</p>

<p>Sounds feasible. But, we somehow need to <strong>skip</strong> the first (initial) value emitted by <code>apples$</code>. Otherwise we end up increasing the score right away which doesn’t make much sense as the game has just started. Turns out RxJS has an operator for that, namely <code>skip()</code>.</p>

<p>The fact that <code>applesEaten$</code> only acts as a <em>publisher</em> to notify other streams, there’s not going to be an Observer subscribing to this stream. Therefore, we have to <strong>manually</strong> subscribe.</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">appleEaten$</span> <span class="o">=</span> <span class="nx">apples$</span>
  <span class="p">.</span><span class="nx">skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">.</span><span class="k">do</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">length$</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">POINTS_PER_APPLE</span><span class="p">))</span>
  <span class="p">.</span><span class="nx">subscribe</span><span class="p">();</span></code></pre></div>

<h2 id="putting-everything-together">Putting everything together</h2>

<p>At this point, we have implemented all core buildings blocks of our game and we are good to go to finally combine everything into one result stream - <code>scene$</code>. For that we’ll use <code>combineLatest</code>. It’s quite similar to <code>withLatestFrom</code> but different in detail. First, let’s look at the code:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">scene$</span> <span class="o">=</span> <span class="nx">Observable</span><span class="p">.</span><span class="nx">combineLatest</span><span class="p">(</span><span class="nx">snake$</span><span class="p">,</span> <span class="nx">apples$</span><span class="p">,</span> <span class="nx">score$</span><span class="p">,</span> <span class="p">(</span><span class="nx">snake</span><span class="p">,</span> <span class="nx">apples</span><span class="p">,</span> <span class="nx">score</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="nx">snake</span><span class="p">,</span> <span class="nx">apples</span><span class="p">,</span> <span class="nx">score</span> <span class="p">}));</span></code></pre></div>

<p>Instead of throttling secondary streams, we are interested in an event whenever <strong>any</strong> of the <em>input</em> Observables produces a new value. The last argument is again a selector function and we are simply taking all the values and returning an object that represents our <strong>game state</strong>. The game state contains everything that needs to be rendered onto the canvas.</p>

<p><img src="/images/snake_scene.png" width="110%" alt="scene" /></p>

<h3 id="maintaining-performance">Maintaining performance</h3>

<p>Not only in games but but also for web applications we aim for performance. Performance can mean a lot but in terms of our game, we’d like to redraw the whole scene 60 times per second.</p>

<p>We can do that by introducing another stream similar to <code>ticks$</code> but for rendering. Basically it’s another interval:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// Interval expects the period to be in milliseconds which is why we devide FPS by 1000</span>
<span class="nx">Observable</span><span class="p">.</span><span class="nx">interval</span><span class="p">(</span><span class="mi">1000</span> <span class="o">/</span> <span class="nx">FPS</span><span class="p">)</span></code></pre></div>

<p>The problem is that JavaScript is single-threaded. The worst case is that we prevent the browser from doing anything so that it locks up. In other words, the browser may not be able to process all these updates quickly enough. The reason for this is that the browser is trying to render a frame and then it’s immediately asked to render the next one. As a result, it drops the current one to keep up the speed. That’s when animations start to look choppy.</p>

<p>Luckily, we can use <code>requestAnimationFrame</code> allowing the browser to line up work and perform it at the most appropriate time. But how do we use it for our Observable pipeline? The good news is that many operators including <code>interval()</code> take a <code>Scheduler</code> as its last argument. In a nutshell, a <code>Scheduler</code> is a mechanism to <strong>schedule</strong> some task to be performed in the future.</p>

<p>While RxJS offers a variety of Schedulers, the one that we’re interested in is called <code>animationFrame</code>. This Scheduler performs a task when <code>window.requestAnimationFrame</code> would fire.</p>

<p>Perfect! Let’s apply this to our interval and we’ll call the resulting Observable <code>game$</code>:</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// Note the last parameter</span>
<span class="kr">const</span> <span class="nx">game$</span> <span class="o">=</span> <span class="nx">Observable</span><span class="p">.</span><span class="nx">interval</span><span class="p">(</span><span class="mi">1000</span> <span class="o">/</span> <span class="nx">FPS</span><span class="p">,</span> <span class="nx">animationFrame</span><span class="p">)</span></code></pre></div>

<p>This interval will now produce values roughly every 16ms maintaining 60 FPS.</p>

<h3 id="rendering-the-scene">Rendering the scene</h3>

<p>What’s left is to combine our <code>game$</code> with the <code>scene$</code>. Can you guess what operator we use for that? Remember, both streams emit at different intervals and the goal now is to render our scene onto the canvas, 60 times per second. We’ll use <code>game$</code> as our <strong>primary</strong> stream and every time it emits a value we combine it with the <strong>latest</strong> value from <code>scene$</code>. Sounds familiar? Yes, we can use <code>withLatestFrom</code> again.</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// Note the last parameter</span>
<span class="kr">const</span> <span class="nx">game$</span> <span class="o">=</span> <span class="nx">Observable</span><span class="p">.</span><span class="nx">interval</span><span class="p">(</span><span class="mi">1000</span> <span class="o">/</span> <span class="nx">FPS</span><span class="p">,</span> <span class="nx">animationFrame</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">withLatestFrom</span><span class="p">(</span><span class="nx">scene$</span><span class="p">,</span> <span class="p">(</span><span class="nx">_</span><span class="p">,</span> <span class="nx">scene</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">scene</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">takeWhile</span><span class="p">(</span><span class="nx">scene</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="nx">isGameOver</span><span class="p">(</span><span class="nx">scene</span><span class="p">))</span>
  <span class="p">.</span><span class="nx">subscribe</span><span class="p">({</span>
    <span class="na">next</span><span class="p">:</span> <span class="p">(</span><span class="nx">scene</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">renderScene</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">scene</span><span class="p">),</span>
    <span class="na">complete</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">renderGameOver</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
  <span class="p">});</span></code></pre></div>

<p>You may have spotted <code>takeWhile()</code> in the code above. It’s another very useful operator that we can call on an exisiting Observable. It will return values from <code>game$</code> <strong>until</strong> <code>isGameOver()</code> returns <code>true</code>.</p>

<p>That’s it! We have just implemented snake, fully reactively and without relying on any external state using nothing but Observables and operators provided by RxJS.</p>

<p>Here’s a live demo for you to play with:</p>

<p><a href="https://stackblitz.com/edit/reactive-snake?file=main.ts" target="_blank" style="border-bottom: 0;">
  <img src="/images/snake_live_demo.png" width="80%" alt="live demo" />
</a></p>

<h2 id="future-work">Future work</h2>

<p>The game is very basic and in a follow-up post we’ll extend it with various features, one of which is restarting the whole game. In addition we’ll look at how we could implement <strong>pause</strong> and <strong>resume</strong> as well as different <strong>levels</strong> of difficulty.</p>

<p>Stay tuned!</p>

<h2 id="special-thanks">Special Thanks</h2>

<p>Special thanks to <a href="https://twitter.com/MrJamesHenry">James Henry</a> and <a href="https://twitter.com/brechtbilliet">Brecht Billiet</a> for their help with the code.</p>


          




        
          <section class="thtrm-ad thtrm-ad--plain thtrm-ad--border thtrm-ad-transparent thtrm-section thtrm-section--is-promo is-sticky">
<a href="https://course.machinelabs.ai" title="Order now!" id="event-cta" ><img src="/images/ml-course-ad.png"></a>
</section>


        </div>

        <div class="thtrm-subscriber">
  <h3>Get updates on new articles and trainings.</h3>
  <p>Join over 2400 other developers who get our content first.</p>
  <form action="//thoughtram.us8.list-manage.com/subscribe/post?u=dfbb1507fbced5a20d9dc5698&amp;id=731f22cdca" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" target="_blank" novalidate>
    <label for="mce-EMAIL"></label>
    <input type="email" value="" name="EMAIL" placeholder="Your email address..." required>
    <div style="position: absolute; left: -5000px;"><input type="text" name="b_dfbb1507fbced5a20d9dc5698_731f22cdca" tabindex="-1" value=""></div>
    <input type="submit" value="Subscribe" name="subscribe" class="thtrm-cta thtrm-cta--small">
  </form>
  <p class="thtrm-form__info-text">Information on the performance measurement included in the consent, the use of the mail service provider MailChimp and on the logging of the registration and your rights of revocation can be found in our <a href="https://thoughtram.io/imprint.html" title="Privacy Statement">data protection declaration</a>.</p>
</div>



        <div class="thtrm-social-links">
            <!-- Sharingbutton Facebook -->
            <a class="resp-sharing-button__link" href="https://facebook.com/sharer/sharer.php?u=http%3A%2F%2Fblog.thoughtram.io/rxjs/2017/08/24/taming-snakes-with-reactive-streams.html" target="_blank" aria-label="Share on Facebook">
              <div class="resp-sharing-button resp-sharing-button--facebook resp-sharing-button--large"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
                <svg version="1.1" x="0px" y="0px" width="24px" height="24px" viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve">
                    <g>
                        <path d="M18.768,7.465H14.5V5.56c0-0.896,0.594-1.105,1.012-1.105s2.988,0,2.988,0V0.513L14.171,0.5C10.244,0.5,9.5,3.438,9.5,5.32 v2.145h-3v4h3c0,5.212,0,12,0,12h5c0,0,0-6.85,0-12h3.851L18.768,7.465z"/>
                    </g>
                </svg>
                </div>Share on Facebook</div>
            </a>

            <!-- Sharingbutton Twitter -->
            <a class="resp-sharing-button__link" href="https://twitter.com/intent/tweet/?text=Taming%20snakes%20with%20reactive%20streams&amp;url=http://blog.thoughtram.io/rxjs/2017/08/24/taming-snakes-with-reactive-streams.html" target="_blank" aria-label="Share on Twitter">
              <div class="resp-sharing-button resp-sharing-button--twitter resp-sharing-button--large"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
                <svg version="1.1" x="0px" y="0px" width="24px" height="24px" viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve">
                    <g>
                        <path d="M23.444,4.834c-0.814,0.363-1.5,0.375-2.228,0.016c0.938-0.562,0.981-0.957,1.32-2.019c-0.878,0.521-1.851,0.9-2.886,1.104 C18.823,3.053,17.642,2.5,16.335,2.5c-2.51,0-4.544,2.036-4.544,4.544c0,0.356,0.04,0.703,0.117,1.036 C8.132,7.891,4.783,6.082,2.542,3.332C2.151,4.003,1.927,4.784,1.927,5.617c0,1.577,0.803,2.967,2.021,3.782 C3.203,9.375,2.503,9.171,1.891,8.831C1.89,8.85,1.89,8.868,1.89,8.888c0,2.202,1.566,4.038,3.646,4.456 c-0.666,0.181-1.368,0.209-2.053,0.079c0.579,1.804,2.257,3.118,4.245,3.155C5.783,18.102,3.372,18.737,1,18.459 C3.012,19.748,5.399,20.5,7.966,20.5c8.358,0,12.928-6.924,12.928-12.929c0-0.198-0.003-0.393-0.012-0.588 C21.769,6.343,22.835,5.746,23.444,4.834z"/>
                    </g>
                </svg>
                </div>Share on Twitter</div>
            </a>

            <!-- Sharingbutton Google+ -->
            <a class="resp-sharing-button__link" href="https://plus.google.com/share?url=http%3A%2F%2Fblog.thoughtram.io/rxjs/2017/08/24/taming-snakes-with-reactive-streams.html" target="_blank" aria-label="Share on Google+">
              <div class="resp-sharing-button resp-sharing-button--google resp-sharing-button--large"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
                <svg version="1.1" x="0px" y="0px" width="24px" height="24px" viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve">
                    <g>
                        <path d="M11.366,12.928c-0.729-0.516-1.393-1.273-1.404-1.505c0-0.425,0.038-0.627,0.988-1.368 c1.229-0.962,1.906-2.228,1.906-3.564c0-1.212-0.37-2.289-1.001-3.044h0.488c0.102,0,0.2-0.033,0.282-0.091l1.364-0.989 c0.169-0.121,0.24-0.338,0.176-0.536C14.102,1.635,13.918,1.5,13.709,1.5H7.608c-0.667,0-1.345,0.118-2.011,0.347 c-2.225,0.766-3.778,2.66-3.778,4.605c0,2.755,2.134,4.845,4.987,4.91c-0.056,0.22-0.084,0.434-0.084,0.645 c0,0.425,0.108,0.827,0.33,1.216c-0.026,0-0.051,0-0.079,0c-2.72,0-5.175,1.334-6.107,3.32C0.623,17.06,0.5,17.582,0.5,18.098 c0,0.501,0.129,0.984,0.382,1.438c0.585,1.046,1.843,1.861,3.544,2.289c0.877,0.223,1.82,0.335,2.8,0.335 c0.88,0,1.718-0.114,2.494-0.338c2.419-0.702,3.981-2.482,3.981-4.538C13.701,15.312,13.068,14.132,11.366,12.928z M3.66,17.443 c0-1.435,1.823-2.693,3.899-2.693h0.057c0.451,0.005,0.892,0.072,1.309,0.2c0.142,0.098,0.28,0.192,0.412,0.282 c0.962,0.656,1.597,1.088,1.774,1.783c0.041,0.175,0.063,0.35,0.063,0.519c0,1.787-1.333,2.693-3.961,2.693 C5.221,20.225,3.66,19.002,3.66,17.443z M5.551,3.89c0.324-0.371,0.75-0.566,1.227-0.566l0.055,0 c1.349,0.041,2.639,1.543,2.876,3.349c0.133,1.013-0.092,1.964-0.601,2.544C8.782,9.589,8.363,9.783,7.866,9.783H7.865H7.844 c-1.321-0.04-2.639-1.6-2.875-3.405C4.836,5.37,5.049,4.462,5.551,3.89z"/>
                        <polygon points="23.5,9.5 20.5,9.5 20.5,6.5 18.5,6.5 18.5,9.5 15.5,9.5 15.5,11.5 18.5,11.5 18.5,14.5 20.5,14.5 20.5,11.5  23.5,11.5   "/>
                    </g>
                </svg>
                </div>Share on Google+</div>
            </a>
        </div>

        <h3 class="thtrm-section-headline thtrm-section-headline--with-margin">Author</h3>
        <div class="thtrm-article-author">
          <span class="thtrm-article-author-avatar"><img src="/images/author_dominic.jpg" alt="Picture of Dominic Elm"></span>
          <div class="thtrm-article-author-matter">
            <h4 class="thtrm-article-author-name">Dominic Elm</h4>
            <p class="thtrm-article-author-text">Dominic is a graduate in computer science and is passionate about many web technologies including Angular, Firebase, and ReactiveX. He has always been enthusiastic about teaching. In fact, Dominic devoted his thesis on the topic of enterprise gamification making the the process of sharing and learning within companies fun and enjoyable for everyone.</p>
            <p>
              <a class="thtrm-article-author-cta thtrm-article-author-cta-twitter" href="https://twitter.com/elmd_" title="Dominic Elm on Twitter">Twitter</a>
              <a class="thtrm-article-author-cta" href="https://github.com/d3lm" title="Dominic Elm on GitHub">GitHub</a>
            </p>
          </div>
        </div>
      </div>

      <div class="thtrm-constraint">

        
        <h4 class="thtrm-section-headline thtrm-section-headline--with-big-margin thtrm-section-headline--centered">Related Posts</h4>
        <ul class="thtrm-three-column-list thtrm-three-column-list--with-padding">
        
        
          
          <li>
            <a class="thtrm-article-card" href="/angular/2018/03/05/advanced-caching-with-rxjs.html" title="Advanced caching with RxJS">
              <div class="thtrm-article-card-image" style="background-image: linear-gradient(to bottom, rgba(0,0,0,0) 0%,rgba(0,0,0,0.01) 2%,#29383E 100%),url(/images/banner/advanced_caching.jpg);"></div>
              <div class="thtrm-article-card-content ">
                <h3>Advanced caching with RxJS</h3>
                <p>When building web applications, performance should always be a top priority. One very efficient way to optimize the performance of...</p>
              </div>
            </a>
          </li>
        
          
          <li>
            <a class="thtrm-article-card" href="/angular/2017/05/08/angular-master-class-redux-and-ngrx.html" title="Angular Master Class - Redux and ngrx">
              <div class="thtrm-article-card-image" style="background-image: linear-gradient(to bottom, rgba(0,0,0,0) 0%,rgba(0,0,0,0.01) 2%,#29383E 100%),url(/images/banner/ngrx_slide_logo.jpg);"></div>
              <div class="thtrm-article-card-content ">
                <h3>Angular Master Class - Redux and ngrx</h3>
                <p>Today we're super excited to announce that we finished working on our new Angular Master Class courseware. Read on for...</p>
              </div>
            </a>
          </li>
        
          
          <li>
            <a class="thtrm-article-card" href="/angular/2017/02/27/three-things-you-didnt-know-about-the-async-pipe.html" title="Three things you didn't know about the AsyncPipe">
              <div class="thtrm-article-card-image" style="background-image: linear-gradient(to bottom, rgba(0,0,0,0) 0%,rgba(0,0,0,0.01) 2%,#29383E 100%),url(/images/banner/three-things-about-the-async-pipe.jpg);"></div>
              <div class="thtrm-article-card-content ">
                <h3>Three things you didn't know about the AsyncPipe</h3>
                <p>This article explains three lesser known features of the AsyncPipe that help us to write better async code.</p>
              </div>
            </a>
          </li>
        
          
          <li>
            <a class="thtrm-article-card" href="/rx/2016/08/01/exploring-rx-operators-flatmap.html" title="Exploring Rx Operators: flatMap">
              <div class="thtrm-article-card-image" style="background-image: linear-gradient(to bottom, rgba(0,0,0,0) 0%,rgba(0,0,0,0.01) 2%,#29383E 100%),url(/images/banner/rx-flatmap.jpeg);"></div>
              <div class="thtrm-article-card-content ">
                <h3>Exploring Rx Operators: flatMap</h3>
                <p>Another post in a series of articles to discover the magic of different Rx operators. In this article we like...</p>
              </div>
            </a>
          </li>
        
          
          <li>
            <a class="thtrm-article-card" href="/angular/2016/06/16/cold-vs-hot-observables.html" title="Cold vs Hot Observables">
              <div class="thtrm-article-card-image" style="background-image: linear-gradient(to bottom, rgba(0,0,0,0) 0%,rgba(0,0,0,0.01) 2%,#29383E 100%),url(/images/banner/hot-vs-cold-observables.jpeg);"></div>
              <div class="thtrm-article-card-content ">
                <h3>Cold vs Hot Observables</h3>
                <p>In this article we are going to demystify what the term hot vs cold means when it comes to Observables....</p>
              </div>
            </a>
          </li>
        
          
          <li>
            <a class="thtrm-article-card" href="/angular/2016/05/16/exploring-rx-operators-map.html" title="Exploring Rx Operators: map">
              <div class="thtrm-article-card-image" style="background-image: linear-gradient(to bottom, rgba(0,0,0,0) 0%,rgba(0,0,0,0.01) 2%,#29383E 100%),url(/images/banner/rx-map.jpg);"></div>
              <div class="thtrm-article-card-content ">
                <h3>Exploring Rx Operators: map</h3>
                <p>This is the first article that is part of a new series where we take a look at different operators...</p>
              </div>
            </a>
          </li>
        
        
        </ul>
        

      

      </div>
    </main>
    <footer role="contentinfo" class="thtrm-footer thtrm-footer--slim">
  <div class="thtrm-footer-text">
    <img class="thtrm-footer-logo" alt="thoughtram brain" src="/images/thoughtram-brain-white.png">
    <p>This website was created in collaboration with <a href="http://twitter.com/timche_" title="Tim Cheung on Twitter"><strong>Tim Cheung</strong></a> and <a href="http://twitter.com/tim_hartmann_" title="Tim Hartmann on Twitter"><strong>Tim Hartmann</strong></a>.</p>
    <p ><a href="https://thoughtram.io/code-of-conduct.html" title="Code of Conduct">Code of Conduct</a> &bullet; <a href="https://thoughtram.io/imprint.html" title="Legal Notice">Legal notice</a></p>
    <p class="thtrm-footer-bottom">&copy; 2014-2018 thoughtram GmbH</p>
  </div>
</footer>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-51360648-2', 'auto');
ga('set', 'anonymizeIp', true);
ga('send', 'pageview');

var form = document.getElementById('search-form');
var eventCta = document.getElementById('event-cta');

if (eventCta) {

  eventCta.addEventListener('click', function (event) {
    event.preventDefault();

    setTimeout(clickLink, 1000);

    function clickLink() {
      window.location.replace(eventCta.getAttribute('href'));
    }

    ga('send', 'event', {
      eventCategory: 'Event Link',
      eventAction: 'click',
      eventLabel: eventCta.getAttribute('title'),
      hitCallback: clickLink
    });
  });
}

if (form) {

  var searchTerm = document.getElementById('search-term');

  form.addEventListener('submit', function(event) {
    event.preventDefault();

    var formSubmitted = false;

    setTimeout(submitForm, 1000);

    function submitForm() {
      if (!formSubmitted) {
        formSubmitted = true;
        form.submit();
      }
    }

    ga('send', 'event', {
      eventCategory: 'Search Form',
      eventAction: 'submit',
      eventLabel: searchTerm.value,
      hitCallback: submitForm
    });
  });
}
</script>



    <script src="/scripts/linkjuice/dist/linkjuice.js"></script>
    <script src="/scripts/main.js"></script>
  </body>
</html>
